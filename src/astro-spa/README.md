# Welcome to Astro SPA ðŸ‘‹

[![npm package](https://img.shields.io/npm/v/astro-spa?style=for-the-badge)](https://npmjs.org/package/astro-spa)
[![npm downloads](https://img.shields.io/npm/dt/astro-spa?style=for-the-badge)](https://npmcharts.com/compare/astro-spa)
[![snyk vulnerability score](https://img.shields.io/snyk/vulnerabilities/npm/astro-spa?style=for-the-badge)](https://snyk.io/advisor/npm-package/astro-spa#security)
[![license](https://img.shields.io/npm/l/astro-spa?style=for-the-badge)](https://github.com/rafidmuhymin/astro-spa/blob/main/license.md)
[![npm maintenance score](https://img.shields.io/npms-io/maintenance-score/astro-spa?style=for-the-badge)](https://npmjs.org/package/astro-spa)
[![npm maintenance score](https://img.shields.io/badge/prs-welcome-brightgreen.svg?style=for-the-badge)](https://github.com/rafidmuhymin/astro-spa/pulls)

The Six UI frameworks supported by Astro for templating are primarily used for building SPA. But the application generated by Astro isn't an SPA. And, it's also not possible because Astro turns the component into plain HTML and ships zero JS!

But to enjoy the advantages of an SPA, I have written a tiny script for my personal project that can turn an Astro website into an SPA. It's not only just an SPA component/library but it comes with many other features also.

## Mechanism

1. It prefetches the internal links using Intersection Observer for blazing-fast navigation
2. It upgrades from prefetch to fetch on mouseover and touchstart if the resource hasn't been prefetched already
3. It caches the prefetched resources using the Cache API
4. It intercepts when you click on an internal link and then it tries to serve the request from cache, if a cache isn't found, it fetches the requested page and replace the current documentElement with the new documentElement
5. If `containerSelector` is available then only that part of the page will get replaced
6. It shows a progress bar if you have selected one
7. Then it executes the scripts of the navigated page
8. It shows a fade-in animation when the new page loads if not disabled
9. It also works with popstate events (back/forward navigation)
10. It clears the entire cache on page load/reloads to ensure there's no stale content
11. If data saver is enabled (on mobile devices), it won't fetch or prefetch the pages
12. It dispatches three functions, prefetch, navigate and observe, that can be called for prefetching, navigating, and observing an anchor element programmatically
13. It has two lifecycle functions, onNavigate & onMount that can be called to add effects and execute code
14. It provides a helper function, scan(), which can be used for detecting new links and observe them

## Installing the plugin

Once you setup your Astro project simply run the following command:

```bash
# yarn
yarn add astro-spa

# npm
npm i astro-spa
```

You can then import the component like this:

```astro
---
import { Spa } from 'astro-spa'
// or import Spa from 'astro-spa/Spa.astro'
---
<Spa/>
```

And that's it, you're now ready to go!

## APIs

### prefetch

You can use the prefetch function to prefetch links programmatically.

```js
const url = "https://example.com";
prefetch(url);
```

### navigate

You can use the navigate function to trigger in-app navigation programmatically.

```js
const searchQuery = "query";
navigate(`/search?${query}`);
```

### observe

You can use the observe function to start observing a new link programmatically. It'll prefetch and add proper event handlers to the link.

```js
const link = document.querySelector("#new-link");
observe(link); // It will start observing the new link
```

### scan

You can use the scan helper function to start observing all the new links injected later into the document via JS like observe function.

```js
const links = ["a link", "another link", "a third link"];

links.forEach((link) => {
  document.body.appendChild(link);
});
scan(); // It will start observing the new three links
```

### w.onNavigate

You can use the global onNavigate lifecycle function to execute code when the user clicks on an internal link

```js
w.onNavigate = () => {
  console.log("navigated");
};
```

### w.onMount

You can use the global onRender lifecycle function to execute code when the navigated pages have completed loading and executed the scripts. It's an alternative to the DOMContentLoaded or window.load event.

```js
w.onMount = () => {
  console.log("mounted");
};
```

## Configuration Options (Component Props)

### beautify

Type: `boolean`

Default: `false`

Whether or not the code should be beautified. If true then the code will be beautified and if false then the code will be minified using terser.

### cache

Type: `boolean`

Default: `true`

Whether or not Cache API will be used for caching the fetched and prefetched resources.

### containerSelector

Type: `string`

Default: `""`

Example: `"#root"`

The querySelector of the element of the page, which will get replaced instead of the whole document.

### defaultAnimation

Type: `boolean`

Default: `true`

Whether or not the default fade-in animation will be displayed on page load.

### delay

Type: `number`

Default: `500`

The amount of time each link needs to stay inside the viewport before being prefetched, in milliseconds.

### external

Type: `boolean`

Default: `false`

Whether the code should be included in an external JavaScript file or be inlined.

### forceRequestIdleCallback

Type: `boolean`

Default: `false`

Whether or not the code will fallback setTimeout if requestIdleCallback isn't supported.

> **Note:** No polyfill gets included when this option is set to true.

### highPriorityPrefetch

Type: `boolean`

Default: `false`

Whether or not the internal links will be prefetched with a higher priority.

### ignores

Type: `array of strings`

Default: `undefined`

The URLs, which should not be fetched or prefetched. However, they won't be excluded from SPA navigation.

### limit

Type: `number`

Default: `undefined`

The maximum number of links that can be prefetched.

### localLinkDetector

Type: `boolean`

Default: `true`

Whether or not the code will check for if any element is using the `data-active-class` attribute and whether its `href` matches the current URL or not.

### PPBColor

Type: `string`

Default: `"#42b3f5"`

The color of the transitioning progress bar.

### prefetch

Type: `boolean`

Default: `true`

Whether or not the internal links will be prefetched.

### prefetchUpgradation

Type: `boolean`

Default: `true`

Whether or not the prefetching of the internal links will be upgraded to fetch on `mouseover` and `touchstart`.

### progressBar

Type: `boolean`

Default: `true`

Whether or not the (primary) progress bar will be displayed.

### root

Type: `string`

Default: `undefined`

Example: `"#viewport"`

The HTML element to observe for in-viewport links to prefetch. However, the links will be fetched on `mouseover` and `touchstart`.

### rootMargin

Type: `string`

Default: `undefined`

The CSS margin property, which should be respected when computing intersection.

### scrollIntoView

Type: `boolean`

Default: `true`

Whether or not the `scrollIntoView` function of the container will be called when using containerization.

### scrollIntoViewOptions

Type: `boolean` | `scrollIntoViewOptions`

Default: `{ behavior: "smooth" }`

It's the parameter of the `scrollIntoView` function. For more info check the article at https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView.

### secondaryProgressBar

Type: `boolean`

Default: `false`

Whether or not the secondary progress bar will be displayed.

> **Note:** The `progressBar` option also must be set to `false`.

### SPBColor

Type: `string`

Default: `#4248f5`

The background color of the secondary progress bar.

### threshold

Type: `number`

Default: `0.25`

The percentage of the area of each link that must have entered the viewport to be fetched, in its decimal form (0.25 = 25%).

### timeout

Type: `number` or `false` (`true` is not a valid value)

Default: `2000`

The amount of time in milliseconds the browser must stay idle before executing the script. If `false` is passed instead of a then the `timeout` won't be passed to `requestIdleCallback`.

> **Note:** There's difference between `{ timeout : 0 }` and no `timeout` key passed. The first will schedule the `idleCallback` to run asynchronously and will call the function after the shortest possible delay. And the second won't call the `idleCallback` until the main thread is free.

## Supported Data Attributes

### data-spa-ignore

Type: `boolean`

If present, the element won't be observed.

### data-spa-no-prefetch

Type: `boolean`

If present, the link won't be prefetched.

### data-spa-high-priority-prefetch

Type: `boolean`

If present, the link will be prefetched with high priority.

### data-spa-no-prefetch-upgradation

Type: `boolean`

If present, prefetching of the link won't be upgraded to fetch on `mouseover` and `touchstart`.

### data-active-class

Type: `string`

If the href attribute of the element is equal to the current URL then the value will be added to the classList of the element.

> **Note:** If `localLinkDetector` is set to `false` then this attribute will be ignored.

## Demos

https://astro-spafy-component-demo.netlify.app/

https://ohka-bots-site-astro-ksoqn4flk7-li4hm4z1a-tc-001.vercel.app/ (Thanks to @Tc-001)

## v2

I am willing to release a v2 that'll utilize the new AppHistory API which is currently only available in Chrome Canary under Experimental Flags.
